<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Engineering Portfolio</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: black;
            color: white;
            display: flex;
        }
        .sidebar {
            width: 200px;
            background-color: black;
            height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .sidebar h2 {
            color: white;
            text-align: center;
            margin-bottom: 20px;
        }
        .sidebar a {
            display: block;
            color: white;
            text-decoration: none;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            background-color: #333;
            text-align: center;
        }
        .sidebar a:hover {
            background-color: #444;
        }
        .content {
            flex: 1;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
        }
        .main-content {
            flex: 1;
            padding-left: 20px;
        }
        .project {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid white;
            border-radius: 8px;
        }
        .project pre {
            background-color: #222;
            color: cyan;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: Consolas, "Courier New", monospace;
        }
        .secondary-sidebar {
            width: 200px;
            background-color: #222;
            height: auto;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            border-left: 1px solid white;
        }
        .secondary-sidebar h2 {
            color: white;
            text-align: center;
            margin-bottom: 20px;
        }
        .secondary-sidebar a {
            display: block;
            color: white;
            text-decoration: none;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            background-color: #333;
            text-align: center;
        }
        .secondary-sidebar a:hover {
            background-color: #444;
        }
        .secondary-content {
            padding: 20px;
            color: white;
        }
        .secondary-content p, .secondary-content li, .secondary-content ol {
            color: white;
            font-family: Arial, sans-serif;
        }
        .secondary-content h3 {
            font-family: Arial, sans-serif;
            color: #58a6ff;
        }
        .secondary-content pre {
            color: cyan;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <h2>Portfolio</h2>
        <a href="#">Projects</a>
    </div>
    <div class="secondary-sidebar">
        <h2>Maze Stack Game!</h2>
        <a href="#game">Game</a>
        <a href="#readme">Readme</a>
        <a href="#code">Code</a>
    </div>
    <div class="content">
        <div id="game" class="secondary-content" style="display: none;">
            <h3>Game</h3>
            <p>The game cannot be run directly in the browser. Please download the code and compile it locally to play the game.</p>
        </div>
        <div id="readme" class="secondary-content" style="display: none;">
            <h3>Readme</h3>
            <p>
                This C++ game demonstrates the use of stacks to manage a series of rooms, each containing elements like doors and treasures. Players navigate these rooms, interacting with the stack's top elements using `push` and `pop` operations to simulate actions like adding and removing items.
            </p>
            <p>
                <strong>Stack Functionality:</strong>
                The game employs the STL `stack` container to model room tiles. Key operations:
            </p>
            <ul>
                <li><strong>`push`:</strong> Adds a tile (e.g., door or treasure) to the room stack.</li>
                <li><strong>`pop`:</strong> Removes the top tile when a player interacts with it.</li>
            </ul>
            <p>
                <strong>Pointers:</strong>
                Pointers in the game track the player's position within a room stack rather than directly manipulating memory addresses. This simplifies navigation logic while leveraging the STL stack's internal memory management.
            </p>
            <p>
                <strong>Memory Implementation:</strong>
                If manual memory management were used instead of STL stacks, the following would be required:
            </p>
            <ol>
                <li>Dynamic allocation of stack nodes with `new`.</li>
                <li>Explicit deallocation using `delete` to prevent memory leaks.</li>
                <li>Custom logic for handling stack overflow and underflow conditions.</li>
            </ol>
            <p>This approach would provide finer control but increase complexity significantly.</p>
        </div>
        <div id="code" class="secondary-content" style="display: block;">
            <h3>Code</h3>
            <pre>
#include <iostream>
#include <vector>
#include <stack>
#include <string>
#include <algorithm>

using namespace std;

typedef stack<char> Room;

vector<Room> rooms;  
int currentRoom = 0; 
int currentPointer = 0;
bool treasureGrabbed = false; 
int treasureRoom = 3; 

void initializeRooms() {
    Room room1, room2, room3, room4;
    room1.push('-'); room1.push('/'); room1.push('-'); room1.push('-'); room1.push('-'); room1.push('-'); room1.push('-'); 
    room2.push('-'); room2.push('-'); room2.push('/'); room2.push('-'); room2.push('-');
    room3.push('-'); room3.push('/'); room3.push('-'); room3.push('-'); room3.push('-');
    room4.push('-'); room4.push('-'); room4.push('*'); room4.push('-'); room4.push('-');
    rooms.push_back(room1);
    rooms.push_back(room2);
    rooms.push_back(room3);
    rooms.push_back(room4);
}

void displayRoom() {
    cout << "Room " << currentRoom + 1 << endl;
    Room roomCopy = rooms[currentRoom]; 
    vector<char> roomTiles;
    while (!roomCopy.empty()) {
        roomTiles.push_back(roomCopy.top());
        roomCopy.pop();
    }
    for (int i = roomTiles.size() - 1; i >= 0; --i) {
        if (i == roomTiles.size() - 1 - currentPointer) {
            cout << ">";
        } else {
            cout << " ";
        }
        cout << roomTiles[i] << endl;
    }
    cout << "w to move up, s to move down, x to enter door, z to grab treasure, q to quit." << endl;
}

void moveUp() {
    if (currentPointer < rooms[currentRoom].size() - 1) {
        currentPointer++;
    } else {
        cout << "Can't move up, already at the bottom." << endl;
    }
}

void moveDown() {
    if (currentPointer > 0) {
        currentPointer--;
    } else {
        cout << "Can't move down, already at the top." << endl;
    }
}

void enterDoor() {
    Room roomCopy = rooms[currentRoom]; 
    vector<char> roomTiles;
    while (!roomCopy.empty()) {
        roomTiles.push_back(roomCopy.top());
        roomCopy.pop();
    }
    char currentTile = roomTiles[roomTiles.size() - 1 - currentPointer];
    if (currentTile == '/') {
        cout << "Entering door" << endl;
        currentRoom = (currentRoom + 1) % rooms.size();
        currentPointer = 0;
    } else {
        cout << "You're not at a door" << endl;
    }
}

void grabTreasure() {
    Room roomCopy = rooms[currentRoom]; 
    vector<char> roomTiles;
    while (!roomCopy.empty()) {
        roomTiles.push_back(roomCopy.top());
        roomCopy.pop();
    }
    char currentTile = roomTiles[roomTiles.size() - 1 - currentPointer];
    if (currentRoom == treasureRoom && currentTile == '*') {
        cout << "You won the game!" << endl;
        treasureGrabbed = true;
        exit(0);
    } else {
        cout << "No treasure here." << endl;
    }
}

void gameLoop() {
    char input;
    while (true) {
        displayRoom();
        cout << "Enter move: ";
        cin >> input;
        if (input == 'q') {
            cout << "Exiting the game. Goodbye!" << endl;
            break;
        } else if (input == 's') {
            moveUp();
        } else if (input == 'w') {
            moveDown();
        } else if (input == 'x') {
            enterDoor();
        } else if (input == 'z') {
            grabTreasure();
        } else {
            cout << "Invalid move." << endl;
        }
    }
}

int main() {
    initializeRooms();
    gameLoop();
    return 0;
}
            </pre>
        </div>
    </div>
    <script>
        // JavaScript to toggle between the content in the secondary sidebar
        const tabs = document.querySelectorAll(".secondary-sidebar a");
        const contents = document.querySelectorAll(".secondary-content");

        tabs.forEach(tab => {
            tab.addEventListener("click", event => {
                event.preventDefault();
                contents.forEach(content => content.style.display = "none");
                const target = document.querySelector(tab.getAttribute("href"));
                if (target) target.style.display = "block";
            });
        });
    </script>
</body>
</html>
